+++
title = "分布式主键"
weight = 2
+++

## 实现动机

传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如MySQL的自增键，Oracle的自增序列等。
数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。
虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。

目前有许多第三方解决方案可以完美解决这个问题，如UUID等依靠特定算法自生成不重复键，或者通过引入主键生成服务等。为了方便用户使用、满足不同用户不同使用场景的需求，
ShardingSphere不仅提供了内置的分布式主键生成器，例如UUID、SNOWFLAKE，还抽离出分布式主键生成器的接口，方便用户自行实现自定义的自增主键生成器。

## 内置的主键生成器

### UUID

采用UUID.randomUUID()的方式产生分布式主键。

### SNOWFLAKE

ShardingSphere提供灵活的配置分布式主键生成策略方式。
在分片规则配置模块可配置每个表的主键生成策略，默认使用雪花算法（snowflake）生成64bit的长整型数据。

雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。

在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。
同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。例如MySQL的Innodb存储引擎的主键。

使用雪花算法生成的主键，二进制表示形式包含4部分，从高位到低位分表为：1bit符号位、41bit时间戳位、10bit工作进程位以及12bit序列号位。

 - 符号位(1bit)

预留的符号位，恒为零。

 - 时间戳位(41bit)

41位的时间戳可以容纳的毫秒数是2的41次幂，一年所使用的毫秒数是：`365 * 24 * 60 * 60 * 1000`。通过计算可知：

```java
Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);
```

结果约等于69.73年。ShardingSphere的雪花算法的时间纪元从2016年11月1日零点开始，可以使用到2086年，相信能满足绝大部分系统的要求。

 - 工作进程位(10bit)

该标志在Java进程内是唯一的，如果是分布式应用部署应保证每个工作进程的id是不同的。该值默认为0，可通过属性设置。

 - 序列号位(12bit)

该序列是用来在同一个毫秒内生成不同的ID。如果在这个毫秒内生成的数量超过4096(2的12次幂)，那么生成器会等待到下个毫秒继续生成。

#### 时钟回拨

服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。
如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。
最大容忍的时钟回拨毫秒数的默认值为0，可通过属性设置。

雪花算法主键的详细结构见下图。

![雪花算法](https://shardingsphere.apache.org/document/current/img/sharding/snowflake_cn_v2.png)

### LEAF

在5.0.0版本之前，借鉴[Leaf](https://tech.meituan.com/2017/04/21/mt-leaf.html)，主要分为Leaf-segment和Leaf-snowflake两种方案。ShardingSphere在4.0.0-RC2-release版本中实现了Leaf-segment，在4.0.0-RC3-release版本中实现了Leaf-snowflake。

从5.0.0版本起，以上两个实现从ShardingSphere中移除。我们重新适配了第三方的[Leaf开源实现](https://github.com/Meituan-Dianping/Leaf)，并移动到[OpenSharding](https://github.com/opensharding/sharding-keygen-leaf)仓库中。具体使用方式，请参考[OpenSharding/sharding-keygen-leaf](https://github.com/opensharding/sharding-keygen-leaf)项目。

